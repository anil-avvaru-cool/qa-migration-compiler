"""
base_parser.py

MVP Responsibility:
- Define canonical AST model
- Provide abstract parser interface
- Ensure structural integrity
- Provide deterministic node IDs
- Include structured logging

Out of Scope:
- Graph building (CG/CFG/DFG)
- Symbol resolution
- Semantic analysis
"""

from __future__ import annotations

import hashlib
import logging
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, validator


# ---------------------------------------------------------------------------
# Logging Configuration
# ---------------------------------------------------------------------------

logger = logging.getLogger("ir_engine.parser.base")
logger.setLevel(logging.INFO)


# ---------------------------------------------------------------------------
# Models
# ---------------------------------------------------------------------------

class SourceLocation(BaseModel):
    line: Optional[int] = None
    column: Optional[int] = None


class CanonicalNode(BaseModel):
    id: str
    node_type: str
    file_path: str
    source_location: Optional[SourceLocation] = None
    attributes: Dict[str, Any] = Field(default_factory=dict)
    parent_id: Optional[str] = None
    children: List["CanonicalNode"] = Field(default_factory=list)

    class Config:
        arbitrary_types_allowed = True
        json_encoders = {}

    @validator("node_type")
    def validate_node_type(cls, v):
        if not v:
            raise ValueError("node_type cannot be empty")
        return v

    def add_child(self, child: "CanonicalNode"):
        self.children.append(child)


CanonicalNode.update_forward_refs()


# ---------------------------------------------------------------------------
# Base Parser
# ---------------------------------------------------------------------------

class BaseParser(ABC):
    """
    Abstract base parser.

    Concrete implementations (e.g., JavaParser) must:
    - Parse source file
    - Convert raw AST to CanonicalNode tree
    """

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.root: Optional[CanonicalNode] = None

    # ---------------------------------------------------------------------
    # Public API
    # ---------------------------------------------------------------------

    def execute(self) -> CanonicalNode:
        logger.info("Parsing started", extra={"file_path": self.file_path})
        self.root = self.parse()
        self._validate_tree(self.root)
        logger.info("Parsing completed", extra={"file_path": self.file_path})
        return self.root

    @abstractmethod
    def parse(self) -> CanonicalNode:
        """
        Must return root CanonicalNode.
        """
        pass

    # ---------------------------------------------------------------------
    # Node Creation Utilities
    # ---------------------------------------------------------------------

    def create_node(
        self,
        node_type: str,
        source_location: Optional[SourceLocation],
        attributes: Optional[Dict[str, Any]] = None,
        parent: Optional[CanonicalNode] = None,
    ) -> CanonicalNode:

        node_id = self._generate_deterministic_id(
            node_type=node_type,
            source_location=source_location,
            parent_id=parent.id if parent else None,
        )

        node = CanonicalNode(
            id=node_id,
            node_type=node_type,
            file_path=self.file_path,
            source_location=source_location,
            attributes=attributes or {},
            parent_id=parent.id if parent else None,
        )

        logger.debug(
            "Node created",
            extra={
                "file_path": self.file_path,
                "node_id": node.id,
                "node_type": node.node_type,
                "line": source_location.line if source_location else None,
            },
        )

        if parent:
            parent.add_child(node)
            logger.debug(
                "Parent-child link established",
                extra={
                    "parent_id": parent.id,
                    "child_id": node.id,
                },
            )

        return node

    # ---------------------------------------------------------------------
    # Deterministic ID Generation
    # ---------------------------------------------------------------------

    def _generate_deterministic_id(
        self,
        node_type: str,
        source_location: Optional[SourceLocation],
        parent_id: Optional[str],
    ) -> str:
        """
        Generates stable ID based on file path + node attributes.
        """
        raw = f"{self.file_path}:{node_type}:{source_location}:{parent_id}"
        return hashlib.sha256(raw.encode()).hexdigest()[:16]

    # ---------------------------------------------------------------------
    # Validation
    # ---------------------------------------------------------------------

    def _validate_tree(self, root: CanonicalNode):

        if not root:
            raise ValueError("Canonical AST root cannot be None")

        visited = set()

        def dfs(node: CanonicalNode):
            if node.id in visited:
                raise ValueError(f"Cycle detected in AST: {node.id}")
            visited.add(node.id)

            for child in node.children:
                if child.parent_id != node.id:
                    raise ValueError(
                        f"Invalid parent linkage for node {child.id}"
                    )
                dfs(child)

        dfs(root)

        logger.info(
            "Tree validation successful",
            extra={"file_path": self.file_path, "node_count": len(visited)},
        )

    # ---------------------------------------------------------------------
    # Export
    # ---------------------------------------------------------------------

    def to_dict(self) -> Dict[str, Any]:
        if not self.root:
            raise ValueError("Parser not executed yet.")
        return self.root.dict()

    def to_json(self) -> str:
        if not self.root:
            raise ValueError("Parser not executed yet.")
        return self.root.json(indent=2)
